<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>
  <critical>Generate all documents in {document_output_language}</critical>
  <critical>Only modify the story file in these areas: Tasks/Subtasks checkboxes, Dev Agent Record (Debug Log, Completion Notes), File List,
    Change Log, and Status</critical>
  <critical>Execute ALL steps in exact order; do NOT skip steps</critical>
  <critical>When {docker_isolation} is enabled, each worktree gets its own Docker Compose project with isolated ports. Port allocation uses slot-based offsets from {docker_port_base}.</critical>
  <critical>Load {conventions} at startup ‚Äî ALL git operations MUST follow documented conventions</critical>
  <critical>Load {board_schema} at startup ‚Äî ALL board operations MUST follow the concurrency protocol</critical>
  <critical>User skill level ({user_skill_level}) affects conversation style ONLY, not code updates.</critical>

  <!-- =================================================================== -->
  <!-- STEP 0: MODE DETECTION                                               -->
  <!-- =================================================================== -->
  <step n="0" goal="Detect if user wants normal story execution or maintenance/cleanup mode">

    <check if="user invoked workflow with 'cleanup' or 'gc' or 'maintenance' argument">
      <goto anchor="gc_mode" />
    </check>

    <!-- Normal flow ‚Äî proceed to Step 1 -->
    <goto step="1" />
  </step>

  <!-- =================================================================== -->
  <!-- GC MODE: GARBAGE COLLECTION / MAINTENANCE                            -->
  <!-- =================================================================== -->
  <anchor id="gc_mode" />
  <step n="gc" goal="Full audit and cleanup of orphaned worktrees, containers, board sessions, and port slots">

    <!-- Resolve project root -->
    <action>Run: git rev-parse --git-common-dir ‚Üí derive {{project_root}}</action>
    <action>Set {{board_path}} = {{project_root}}/{board_dir}/sprint-board.yaml</action>

    <check if="{{board_path}} does NOT exist">
      <output>üìã No sprint board found ‚Äî nothing to clean up.</output>
      <action>HALT</action>
    </check>

    <!-- ===== PHASE 1: AUDIT ===== -->
    <action>Read COMPLETE sprint-board.yaml</action>

    <!-- Audit worktrees on disk vs board -->
    <action>List all directories under {{project_root}}/{worktree_dir}/</action>
    <action>List all git worktrees via: git worktree list --porcelain</action>
    <action>Cross-reference with board sessions to identify:
      - **Orphaned worktrees**: directories on disk with no matching board session
      - **Ghost sessions**: board sessions whose worktree directory is missing
      - **Active sessions**: board sessions with existing worktrees
    </action>

    <!-- Audit Docker containers (if docker_isolation enabled) -->
    <check if="{docker_isolation} is true">
      <action>List all running Docker Compose projects matching pattern "alquileres-wt-*":
        docker compose ls --format json | filter by project name prefix</action>
      <action>Cross-reference with board sessions to identify:
        - **Orphaned containers**: running Docker projects with no matching board session
        - **Stopped containers**: board sessions with compose_project but containers not running
        - **Active containers**: running Docker projects with matching active session
      </action>
      <action>List all allocated port_slots from board sessions</action>
    </check>

    <!-- Audit branches -->
    <action>List all local branches matching feat/*, fix/*, refactor/*, chore/* patterns</action>
    <action>Cross-reference with board sessions to identify orphaned branches</action>

    <!-- ===== PHASE 2: REPORT ===== -->
    <output>üîç **Resource Audit Report**

      **Board Sessions ({{total_sessions}}):**
      {{for each session}}
      - {{session_id}}: {{story_key}} [{{status}}]
        Last activity: {{last_checkpoint}} ({{hours_ago}}h ago)
        Worktree: {{worktree_status}} | Branch: {{branch_status}}
        {{if docker_isolation}}Docker: {{container_status}} | Port slot: {{port_slot}}{{/if}}
      {{/for}}

      **Orphaned Resources:**
      - Worktree directories without board session: {{orphaned_worktrees_count}}
        {{orphaned_worktrees_list}}
      - Board sessions without worktree on disk: {{ghost_sessions_count}}
        {{ghost_sessions_list}}
      - Orphaned branches: {{orphaned_branches_count}}
        {{orphaned_branches_list}}
      {{if docker_isolation}}
      - Orphaned Docker projects: {{orphaned_containers_count}}
        {{orphaned_containers_list}}
      - Port slots in use: {{used_slots}} / {docker_max_worktrees}
      {{/if}}

      ---
      **Cleanup Options:**
      üßπ **[A] Clean ALL orphaned resources** ‚Äî Remove everything not tied to an active session
      üéØ **[S] Selective cleanup** ‚Äî Choose which resources to clean
      üõë **[F] Force clean EVERYTHING** ‚Äî Stop all sessions, remove all worktrees and containers
      ‚ùå **[X] Exit** ‚Äî Do nothing
    </output>

    <ask>Choose cleanup option [A/S/F/X]:</ask>

    <!-- OPTION A: Clean all orphaned -->
    <check if="user chooses 'A'">
      <action>For each orphaned worktree:
        - git worktree remove {{path}} --force</action>

      <check if="{docker_isolation} is true">
        <action>For each orphaned Docker project:
          - docker compose -p {{project_name}} down -v</action>
      </check>

      <action>For each orphaned branch:
        - git branch -D {{branch_name}}</action>

      <action>Acquire board lock</action>
      <action>For each ghost session:
        - Remove session from board
        - Reset story status to "ready-for-dev", clear claimed_by</action>
      <action>Release board lock</action>

      <output>üßπ **Orphan cleanup complete**
        Worktrees removed: {{count}}
        Branches deleted: {{count}}
        {{if docker_isolation}}Docker projects stopped: {{count}}
        Port slots freed: {{count}}{{/if}}
        Board sessions cleaned: {{count}}
      </output>
    </check>

    <!-- OPTION S: Selective cleanup -->
    <check if="user chooses 'S'">
      <output>**Select resources to clean up** (comma-separated numbers, or 'all'):</output>

      <action>Present numbered list of ALL cleanable resources:
        1. [worktree] .worktrees/1-2-story-name (orphaned)
        2. [docker] alquileres-wt-1-3-other (orphaned, ports 10210-10213)
        3. [session] sess-abc123 ‚Äî 1-4-story (ghost, worktree missing)
        4. [branch] feat/1-2-story-name (orphaned)
        5. [session] sess-def456 ‚Äî 1-5-story (stale, {{hours_ago}}h inactive)
        ...
      </action>

      <ask>Which resources to clean? (e.g., "1,2,4" or "all"):</ask>

      <action>Execute cleanup only for selected resources</action>
      <action>For sessions being cleaned: also clean associated worktree, branch, and Docker project</action>
      <action>Acquire board lock, update board, release lock</action>

      <output>üßπ **Selective cleanup complete**
        {{summary_of_cleaned_resources}}
      </output>
    </check>

    <!-- OPTION F: Force clean everything -->
    <check if="user chooses 'F'">
      <output>‚ö†Ô∏è **WARNING: This will stop ALL sessions, remove ALL worktrees, and destroy ALL containers.**
        Any uncommitted work will be lost. Committed but unpushed work will also be lost.

        **Are you absolutely sure?**
      </output>

      <ask>Type "CONFIRM" to proceed, anything else to cancel:</ask>

      <check if="user types 'CONFIRM'">
        <!-- Stop all Docker projects -->
        <check if="{docker_isolation} is true">
          <action>For each session with compose_project:
            docker compose -p {{compose_project}} down -v</action>
          <action>For each orphaned Docker project:
            docker compose -p {{project_name}} down -v</action>
        </check>

        <!-- Remove all worktrees -->
        <action>For each worktree in {worktree_dir}/:
          git worktree remove {{path}} --force</action>

        <!-- Delete all session branches -->
        <action>For each session branch:
          git branch -D {{branch_name}}</action>

        <!-- Reset board -->
        <action>Acquire board lock</action>
        <action>Remove ALL sessions from board</action>
        <action>Reset all non-"done" stories to "ready-for-dev", clear claimed_by</action>
        <action>Release board lock</action>

        <output>üî• **Full cleanup complete**
          All sessions terminated.
          All worktrees removed.
          {{if docker_isolation}}All Docker containers destroyed.
          All port slots freed.{{/if}}
          Board reset to clean state.
        </output>
      </check>

      <check if="user did NOT type 'CONFIRM'">
        <output>‚ùå Force cleanup cancelled.</output>
      </check>
    </check>

    <check if="user chooses 'X'">
      <output>üëã Exiting maintenance mode. No changes made.</output>
    </check>

    <action>HALT ‚Äî maintenance mode complete</action>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 1: CLAIM STORY                                                  -->
  <!-- =================================================================== -->
  <step n="1" goal="Find an available story and claim it on the sprint board">

    <!-- Generate session ID -->
    <action>Generate a unique session ID: sess-{random-6-hex-chars}</action>
    <action>Store as {{session_id}}</action>

    <!-- Resolve project root (works from worktree too) -->
    <action>Run: git rev-parse --git-common-dir ‚Üí derive {{project_root}} as parent of .git dir</action>
    <action>Set {{board_path}} = {{project_root}}/{board_dir}/sprint-board.yaml</action>

    <!-- Initialize board if needed -->
    <check if="{{board_path}} does NOT exist">
      <action>Create directory {{project_root}}/{board_dir}/</action>
      <action>Add {board_dir}/ to .gitignore if not already present</action>
      <action>Add {worktree_dir}/ to .gitignore if not already present</action>

      <check if="{{sprint_status}} file exists">
        <action>Read {{sprint_status}} and extract all story keys and statuses</action>
        <action>Populate sprint-board.yaml stories section from sprint-status data</action>
        <action>Map statuses: ready-for-dev ‚Üí ready-for-dev, in-progress ‚Üí ready-for-dev (reset unclaimed), done ‚Üí done</action>
      </check>

      <check if="{{sprint_status}} does NOT exist">
        <action>Search {story_dir} for story files matching *-*-*.md</action>
        <action>Read each story file status section</action>
        <action>Populate sprint-board.yaml stories section from discovered story files</action>
      </check>

      <output>üìã Sprint board initialized at {board_dir}/sprint-board.yaml</output>
    </check>

    <!-- ============================================================= -->
    <!-- STALE SESSION DETECTION (automatic on every run)              -->
    <!-- ============================================================= -->
    <action>Read sprint-board.yaml sessions section</action>
    <action>For each session where status is NOT "done":
      - Calculate hours since last_checkpoint (or started_at if no checkpoint)
      - If hours > {docker_stale_hours}, mark session as stale candidate
      - Also check if the worktree directory still exists on disk
      - Also check if the git branch still exists
    </action>

    <check if="stale sessions found">
      <output>‚ö†Ô∏è **Stale sessions detected** (inactive > {docker_stale_hours}h):

        {{for each stale session}}
        - **{{session_id}}**: {{story_key}}
          Status: {{status}} | Last activity: {{last_checkpoint}} ({{hours_ago}}h ago)
          Worktree: {{worktree_exists ? "exists" : "missing"}}
          {{if docker_isolation}}Docker: {{compose_project}} (slot {{port_slot}}){{/if}}
        {{/for}}

        **Options:**
        üßπ **[C] Clean up stale sessions** ‚Äî Stop containers, remove worktrees, free board slots
        ‚è≠Ô∏è **[S] Skip** ‚Äî Ignore and continue to story selection
      </output>

      <ask>Clean up stale sessions? [C/S]:</ask>

      <check if="user chooses 'C' (Clean up)">
        <action>For each stale session, execute cleanup sequence:</action>

        <!-- Docker cleanup per stale session -->
        <check if="{docker_isolation} is true AND session has compose_project">
          <action>Stop and remove containers:
            docker compose -p {{compose_project}} down -v</action>
          <action>Remove {{worktree_path}}/{docker_env_file} if it exists</action>
        </check>

        <!-- Git cleanup per stale session -->
        <check if="worktree exists at {{worktree_path}}">
          <action>Remove worktree: git worktree remove {{worktree_path}} --force</action>
        </check>
        <check if="branch {{branch_name}} exists locally">
          <action>Delete branch: git branch -D {{branch_name}}</action>
        </check>

        <!-- Board cleanup -->
        <action>Acquire board lock</action>
        <action>For each cleaned session:
          - Remove session from sessions registry
          - Reset story status to "ready-for-dev" and clear claimed_by
        </action>
        <action>Release board lock</action>

        <output>üßπ **Cleanup complete**
          Sessions removed: {{cleaned_count}}
          Worktrees removed: {{worktrees_removed_count}}
          {{if docker_isolation}}Docker projects stopped: {{docker_projects_stopped}}
          Port slots freed: {{slots_freed}}{{/if}}
        </output>
      </check>
    </check>

    <!-- Check for explicit story path -->
    <check if="{{story_path}} is provided">
      <action>Use {{story_path}} directly</action>
      <action>Read COMPLETE story file</action>
      <action>Extract story_key from filename or metadata</action>
      <goto anchor="claim_story" />
    </check>

    <!-- Find available story from board -->
    <action>Acquire board lock (follow concurrency protocol from {board_schema})</action>
    <action>Read COMPLETE sprint-board.yaml</action>
    <action>Find the FIRST story where:
      - status == "ready-for-dev"
      - claimed_by is empty
      - Key matches pattern: number-number-name (NOT epic or retrospective keys)
    </action>
    <action>Release board lock</action>

    <check if="no available story found">
      <output>üìã No available stories on the sprint board.

        **Active Sessions:**
        {{list_active_sessions}}

        **What would you like to do?**
        1. Run `create-story` to create next story from epics
        2. Specify a story file path to develop
        3. Review the sprint board
        4. üßπ Run maintenance/cleanup (audit and clean orphaned resources)
      </output>
      <ask>Choose option [1], [2], [3], or [4]:</ask>

      <check if="user chooses '1'">
        <action>HALT ‚Äî Run create-story workflow</action>
      </check>
      <check if="user chooses '2'">
        <ask>Provide the story file path:</ask>
        <action>Store as {{story_path}}</action>
        <goto anchor="claim_story" />
      </check>
      <check if="user chooses '3'">
        <action>Display full sprint board state</action>
        <action>HALT ‚Äî User reviews board</action>
      </check>
      <check if="user chooses '4'">
        <goto anchor="gc_mode" />
      </check>
    </check>

    <anchor id="claim_story" />

    <!-- Claim the story on the board -->
    <action>Acquire board lock</action>
    <action>Re-read board to verify story is still available (guard against race condition)</action>
    <check if="story was claimed by another session between reads">
      <action>Release board lock</action>
      <output>‚ö†Ô∏è Story was claimed by another session. Searching for next available...</output>
      <goto step="1" />
    </check>
    <action>Update story status to "claimed", set claimed_by = {{session_id}}</action>
    <action>Register session in sessions section: story, status="claimed", started_at</action>
    <action>Release board lock</action>

    <action>Store {{story_key}}</action>
    <action>Find and read COMPLETE story file from {story_dir}/{{story_key}}.md</action>
    <action>Parse sections: Story, Acceptance Criteria, Tasks/Subtasks, Dev Notes, Dev Agent Record, File List, Change Log, Status</action>

    <output>‚úÖ Story claimed: {{story_key}}
      Session: {{session_id}}
    </output>

    <action if="story file inaccessible">HALT: "Cannot develop story without access to story file"</action>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 2: SETUP WORKTREE + BRANCH                                     -->
  <!-- =================================================================== -->
  <step n="2" goal="Create git branch and worktree for isolated development">

    <!-- Load conventions for branch naming -->
    <action>Load {conventions} to determine branch type</action>
    <action>Determine branch type from story context:
      - Feature story ‚Üí feat/
      - Bug fix story ‚Üí fix/
      - Refactoring story ‚Üí refactor/
      - Maintenance story ‚Üí chore/
    </action>
    <action>Set {{branch_name}} = {type}/{{story_key}} (following conventions)</action>

    <!-- Ensure main is up to date -->
    <action>From project root: git fetch origin</action>
    <action>Verify main is up to date with origin/main</action>

    <!-- Create worktree -->
    <action>Set {{worktree_path}} = {{project_root}}/{worktree_dir}/{{story_key}}</action>

    <check if="worktree already exists at {{worktree_path}}">
      <output>‚èØÔ∏è Existing worktree found for {{story_key}} ‚Äî resuming development</output>
      <action>Verify the worktree branch matches {{branch_name}}</action>

      <!-- Resume Docker containers if worktree already exists -->
      <check if="{docker_isolation} is true AND {{worktree_path}}/{docker_env_file} exists">
        <action>Restart stopped containers:
          docker compose --env-file {docker_env_file} -p alquileres-wt-{{story_key}} up -d</action>
        <action>Wait for health checks</action>
        <output>üê≥ Docker containers resumed</output>
      </check>
    </check>

    <check if="worktree does NOT exist">
      <action>Create directory {worktree_dir}/ if it doesn't exist</action>
      <action>Run: git worktree add {{worktree_path}} -b {{branch_name}} main</action>
    </check>

    <!-- Update board with branch and worktree info -->
    <action>Acquire board lock</action>
    <action>Update session: branch={{branch_name}}, worktree={{worktree_path}}, status="in-progress"</action>
    <action>Update story: status="in-progress", branch={{branch_name}}</action>
    <action>Release board lock</action>

    <!-- CRITICAL: Change working directory -->
    <critical>ALL subsequent file operations and git commands MUST execute from {{worktree_path}}</critical>
    <action>Change working directory to {{worktree_path}}</action>

    <!-- ============================================================= -->
    <!-- DOCKER ENVIRONMENT SETUP (only when docker_isolation enabled)  -->
    <!-- ============================================================= -->
    <check if="{docker_isolation} is true">

      <!-- Allocate port slot for this worktree -->
      <action>Read sprint-board.yaml to find all active sessions and their allocated port slots</action>
      <action>Each session should have a "port_slot" field (integer 1-{docker_max_worktrees})</action>
      <action>Find the LOWEST available slot not used by any active session</action>

      <check if="no available slot">
        <action>HALT: "Maximum parallel worktrees ({docker_max_worktrees}) reached. Stop another session's containers first."</action>
      </check>

      <action>Store {{port_slot}}</action>
      <action>Calculate port offset: {{port_offset}} = {{port_slot}} * {docker_port_step}</action>

      <!-- Generate .env.ports file in the worktree -->
      <action>Generate {{worktree_path}}/{docker_env_file} with calculated ports:
        COMPOSE_PROJECT_NAME=alquileres-wt-{{story_key}}
        PORT_API={{docker_port_base + port_offset}}
        PORT_DB={{docker_port_base + port_offset + 1}}
        PORT_CACHE={{docker_port_base + port_offset + 2}}
        PORT_POWERSYNC={{docker_port_base + port_offset + 3}}
      </action>

      <!-- Ensure .env.ports is in .gitignore -->
      <action>Add {docker_env_file} to .gitignore if not already present</action>

      <!-- Handle shared services -->
      <check if="{docker_shared_services} is NOT empty">
        <action>Verify shared services are running on base ports (slot 0).
          If not, start them: docker compose --env-file with base ports up -d {shared_service_names}</action>
        <action>In the generated {docker_env_file}, keep shared service ports at their base values</action>
        <action>Only offset ports for non-shared services</action>
      </check>

      <!-- Start containers -->
      <action>From {{worktree_path}}, run:
        docker compose --env-file {docker_env_file} -p alquileres-wt-{{story_key}} up -d</action>
      <action>Wait for health checks to pass</action>

      <!-- Run migrations if DB is not shared -->
      <check if="postgres is NOT in {docker_shared_services}">
        <action>Run database migrations against the worktree's DB container</action>
      </check>

      <!-- Update board with port info -->
      <action>Acquire board lock</action>
      <action>Update session: port_slot={{port_slot}}, compose_project="alquileres-wt-{{story_key}}"</action>
      <action>Release board lock</action>

      <output>üê≥ Docker environment ready
        Project: alquileres-wt-{{story_key}}
        Port slot: {{port_slot}} (offset +{{port_offset}})
        API: {{calculated_api_port}}
        DB: {{calculated_db_port}}
        Cache: {{calculated_cache_port}}
        PowerSync: {{calculated_powersync_port}}
        {{shared_services_note}}
      </output>
    </check>

    <check if="{docker_isolation} is false OR not set">
      <output>‚ÑπÔ∏è Docker isolation disabled ‚Äî using shared/manual container management</output>
    </check>

    <output>üåø Worktree ready
      Branch: {{branch_name}}
      Path: {{worktree_path}}
      Working directory set to worktree.
    </output>

    <action if="git worktree add fails">HALT: "Failed to create worktree. Check if branch already exists or worktree path is in use."</action>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 3: LOAD CONTEXT + DETECT STACK                                 -->
  <!-- =================================================================== -->
  <step n="3" goal="Load project context, detect tech stack, and load specialized agent patterns">

    <action>Load {project_context} for coding standards and project-wide patterns (if exists)</action>
    <action>Load comprehensive context from story file's Dev Notes section</action>
    <action>Extract developer guidance from Dev Notes: architecture requirements, previous learnings, technical specifications</action>

    <!-- Stack detection -->
    <check if="{default_stack} == 'auto'">
      <action>Auto-detect stack from project files in worktree:
        - package.json with "react-native" dependency ‚Üí react-native
        - package.json with "react" (no react-native) ‚Üí react
        - composer.json with "laravel/framework" ‚Üí laravel
        - Multiple detected ‚Üí ask user
        - None detected ‚Üí ask user
      </action>
    </check>

    <check if="{default_stack} != 'auto'">
      <action>Use {default_stack} as the stack</action>
    </check>

    <action>Store detected stack as {{active_stack}}</action>

    <!-- Load stack-specific patterns -->
    <action>Load {stack_patterns_dir}/{{active_stack}}.md for stack-specific:
      - Project structure conventions
      - Testing tools and patterns (TDD approach)
      - Coding standards
      - Common patterns and anti-patterns
    </action>

    <!-- Detect review continuation -->
    <check if="Senior Developer Review (AI) section exists in story file">
      <action>Set review_continuation = true</action>
      <action>Extract pending review items</action>
      <output>‚èØÔ∏è **Resuming After Code Review**
        Review items remaining: {{unchecked_review_count}}
        Strategy: Address review follow-ups first, then continue with regular tasks.
      </output>
    </check>

    <check if="Senior Developer Review section does NOT exist">
      <action>Set review_continuation = false</action>
    </check>

    <action>Identify first incomplete task (unchecked [ ]) in Tasks/Subtasks</action>

    <output>‚úÖ **Context Loaded**
      Story: {{story_key}}
      Stack: {{active_stack}}
      First task: {{first_task_description}}
      Total tasks: {{total_tasks}} ({{completed_tasks}} done, {{remaining_tasks}} remaining)
    </output>

    <action if="no incomplete tasks">
      <goto step="7">Story already complete ‚Äî generate verification</goto>
    </action>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 4: IMPLEMENT TASK (Red-Green-Refactor)                          -->
  <!-- =================================================================== -->
  <step n="4" goal="Implement current task following TDD cycle with stack-specific patterns">
    <critical>FOLLOW THE STORY FILE TASKS/SUBTASKS SEQUENCE EXACTLY AS WRITTEN ‚Äî NO DEVIATION</critical>
    <critical>Apply {{active_stack}} patterns from loaded stack patterns file</critical>

    <action>Review the current task/subtask from the story file</action>
    <action>Plan implementation using stack-specific patterns and TDD cycle</action>

    <!-- RED PHASE -->
    <action>Write FAILING tests first for the task/subtask functionality</action>
    <action>Use testing tools appropriate for {{active_stack}} (from stack patterns)</action>
    <action>Confirm tests fail before implementation ‚Äî this validates test correctness</action>

    <!-- GREEN PHASE -->
    <action>Implement MINIMAL code to make tests pass</action>
    <action>Run tests to confirm they now pass</action>
    <action>Handle error conditions and edge cases as specified in task/subtask</action>

    <!-- REFACTOR PHASE -->
    <action>Improve code structure while keeping tests green</action>
    <action>Ensure code follows architecture patterns and coding standards from Dev Notes and stack patterns</action>

    <action if="new dependencies required beyond story specifications">HALT: "Additional dependencies need user approval"</action>
    <action if="3 consecutive implementation failures occur">HALT and request guidance</action>
    <action if="required configuration is missing">HALT: "Cannot proceed without necessary configuration files"</action>

    <critical>NEVER implement anything not mapped to a specific task/subtask in the story file</critical>
    <critical>NEVER proceed to next step until current task tests pass</critical>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 5: CHECKPOINT VALIDATION                                        -->
  <!-- =================================================================== -->
  <step n="5" goal="Present changes for manual review before committing">

    <!-- Verify Docker containers are running before tests -->
    <check if="{docker_isolation} is true">
      <action>Verify Docker containers are running:
        docker compose -p alquileres-wt-{{story_key}} ps --format json</action>
      <check if="containers are not running">
        <action>Restart containers:
          docker compose --env-file {docker_env_file} -p alquileres-wt-{{story_key}} up -d</action>
        <action>Wait for health checks</action>
      </check>
    </check>

    <!-- Run validations -->
    <action>Determine test runner from project structure and stack patterns</action>
    <action>Run tests relevant to the current task</action>
    <action>Run full test suite to check for regressions</action>
    <action>Run linting/formatting if configured</action>

    <!-- Prepare checkpoint summary -->
    <action>Generate diff summary: git diff --stat</action>
    <action>Count lines changed: additions, deletions</action>
    <action>List files modified, created, deleted</action>

    <output>üìç **Checkpoint ‚Äî Task {{current_task_number}}: {{current_task_title}}**

      **Changes:**
      {{diff_stat_summary}}

      **Files ({{files_count}}):**
      {{files_list_with_status}}

      **Tests:**
      - New tests: {{new_tests_count}} ({{new_tests_status}})
      - Full suite: {{full_suite_status}} ({{total_tests}} tests)
      - Linting: {{lint_status}}

      **What was implemented:**
      {{brief_implementation_description}}

      ---
      ‚úÖ **[A] Approve** ‚Äî Commit and continue to next task
      üîÑ **[F] Request Fix** ‚Äî Describe what needs to change
      ‚ùå **[R] Reject** ‚Äî Revert changes and re-implement
      ‚è∏Ô∏è **[P] Pause** ‚Äî Stash changes and halt session
    </output>

    <ask>Your decision [A/F/R/P]:</ask>

    <check if="user chooses 'A' (Approve)">
      <goto step="6" />
    </check>

    <check if="user chooses 'F' (Fix)">
      <ask>What needs to be fixed?</ask>
      <action>Apply requested fixes</action>
      <goto step="5">Re-validate after fix</goto>
    </check>

    <check if="user chooses 'R' (Reject)">
      <action>Revert all uncommitted changes: git checkout -- .</action>
      <action>Clean untracked files if needed: git clean -fd (only new files from this task)</action>
      <output>‚Ü©Ô∏è Changes reverted. Re-implementing task...</output>
      <goto step="4">Re-implement task</goto>
    </check>

    <check if="user chooses 'P' (Pause)">
      <action>Stash changes: git stash push -m "WIP: {{story_key}} task {{current_task_number}}"</action>

      <!-- Stop Docker containers on pause (keep volumes for resume) -->
      <check if="{docker_isolation} is true">
        <action>Stop containers (keep volumes):
          docker compose -p alquileres-wt-{{story_key}} stop</action>
        <output>üê≥ Docker containers stopped (volumes preserved for resume)</output>
      </check>

      <action>Acquire board lock</action>
      <action>Update session status = "blocked", update last_checkpoint</action>
      <action>Release board lock</action>
      <output>‚è∏Ô∏è Session paused. Changes stashed.
        To resume: run dev-story workflow ‚Äî it will detect the existing worktree and stashed changes.
      </output>
      <action>HALT ‚Äî session paused by user</action>
    </check>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 6: COMMIT + UPDATE STORY                                        -->
  <!-- =================================================================== -->
  <step n="6" goal="Commit approved changes and update story file">

    <!-- Validate task completion before marking -->
    <critical>NEVER mark a task complete unless ALL conditions are met</critical>
    <action>Verify ALL tests for this task ACTUALLY EXIST and PASS 100%</action>
    <action>Confirm implementation matches EXACTLY what the task/subtask specifies</action>

    <!-- Update story file -->
    <action>Mark the task (and subtasks) checkbox with [x]</action>
    <action>Update File List section with new/modified/deleted files (paths relative to repo root)</action>
    <action>Add entry to Change Log with task description and date</action>
    <action>Add notes to Dev Agent Record summarizing what was implemented and tested</action>

    <!-- Handle review follow-ups -->
    <check if="task is review follow-up (has [AI-Review] prefix)">
      <action>Mark task checkbox [x] in Review Follow-ups section</action>
      <action>Mark corresponding action item in Senior Developer Review section</action>
      <action>Add to Dev Agent Record: "Resolved review finding [{{severity}}]: {{description}}"</action>
    </check>

    <!-- Commit following conventions -->
    <action>Load {conventions} for commit message format</action>
    <action>Stage all changes: git add -A</action>
    <action>Commit with conventional message:
      {type}({{story_key}}): {{task_description}}

      Task: {{task_number}} - {{task_title}}
      Story: {{story_key}}
    </action>

    <!-- Update board -->
    <action>Acquire board lock</action>
    <action>Update session: last_checkpoint = now, current_task = next task description</action>
    <action>Release board lock</action>

    <output>‚úÖ Task {{current_task_number}} committed: {{commit_hash_short}}</output>

    <!-- Loop or complete -->
    <action>Determine if more incomplete tasks remain</action>
    <check if="more tasks remain">
      <output>‚û°Ô∏è Next task: {{next_task_description}}</output>
      <goto step="4">Next task</goto>
    </check>
    <check if="no tasks remain">
      <goto step="7">Story complete</goto>
    </check>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 7: STORY COMPLETE ‚Äî MANUAL VERIFICATION CHECKLIST               -->
  <!-- =================================================================== -->
  <step n="7" goal="Generate manual verification checklist from acceptance criteria">

    <action>Verify ALL tasks and subtasks are marked [x] (re-scan story file)</action>
    <action>Run the full regression suite one final time</action>
    <action>Confirm File List includes every changed file</action>

    <!-- Generate manual verification steps -->
    <action>Read ALL acceptance criteria from the story file</action>
    <action>For each AC, generate specific, actionable verification steps:
      - What to do (step by step)
      - What to expect (expected result)
      - How to verify (what to check)
    </action>

    <output>üß™ **Manual Verification Checklist ‚Äî {{story_key}}**

      All tasks complete. Please verify the following before proceeding:

      {{generated_verification_checklist}}

      ---
      After verifying:
      ‚úÖ **[V] Verified** ‚Äî Everything works, proceed to code review + PR
      üîÑ **[I] Issues found** ‚Äî Describe what's wrong
    </output>

    <ask>Verification result [V/I]:</ask>

    <check if="user chooses 'V' (Verified)">
      <goto step="8" />
    </check>

    <check if="user chooses 'I' (Issues)">
      <ask>Describe the issues found:</ask>
      <action>Analyze reported issues and determine which task(s) need rework</action>
      <action>Create fix plan for reported issues</action>
      <goto step="4">Fix issues</goto>
    </check>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 8: CODE REVIEW + MANUAL APPROVAL                               -->
  <!-- =================================================================== -->
  <step n="8" goal="Facilitate code review and final approval">

    <output>üìù **Ready for Code Review ‚Äî {{story_key}}**

      **Recommended:** Run the `code-review` workflow using a **different LLM** than this session.

      **Options:**
      1. Run `code-review` workflow now (will HALT this session ‚Äî resume after review)
      2. Skip code review and proceed to PR creation
      3. Mark that code review was already done externally
    </output>

    <ask>Choose option [1], [2], or [3]:</ask>

    <check if="user chooses '1'">
      <action>Update story Status to "review"</action>
      <action>Acquire board lock</action>
      <action>Update session status = "review"</action>
      <action>Update story status = "review"</action>
      <action>Release board lock</action>
      <output>‚è∏Ô∏è Session paused for code review.
        After review, run dev-story again ‚Äî it will detect the review results and resume.
        üí° Tip: Use a different LLM for the code review for best results.
      </output>
      <action>HALT ‚Äî waiting for code review</action>
    </check>

    <check if="user chooses '2' or '3'">
      <goto step="9" />
    </check>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 9: FINALIZE ‚Äî PR CREATION                                       -->
  <!-- =================================================================== -->
  <step n="9" goal="Push branch, create PR, and update sprint board">

    <!-- Final commit if any pending changes -->
    <action>Check for uncommitted changes (story file updates, etc.)</action>
    <check if="uncommitted changes exist">
      <action>Stage and commit: chore({{story_key}}): finalize story for review</action>
    </check>

    <!-- Push branch -->
    <action>Push branch to remote: git push -u origin {{branch_name}}</action>

    <!-- Create PR -->
    <action>Load {conventions} for PR format</action>
    <action>Load PR template from {project-root}/_bmad/bmm-multi-dev/templates/pr-template.md</action>
    <action>Generate PR body:
      - Story key, title, epic
      - Implementation summary (from Dev Agent Record)
      - Changes list (from Change Log)
      - Acceptance criteria checklist
      - Manual verification steps (from step 7)
    </action>
    <action>Create PR via: gh pr create --title "{{pr_title}}" --body "{{pr_body}}"</action>
    <action>Store {{pr_url}} from gh output</action>

    <!-- Update story file -->
    <action>Update story Status to "review"</action>
    <action>Add PR URL to Dev Agent Record</action>
    <action>Commit and push: chore({{story_key}}): add PR reference</action>

    <!-- Update sprint board -->
    <action>Acquire board lock</action>
    <action>Update story: status="review", pr_url={{pr_url}}</action>
    <action>Update session: status="review"</action>
    <action>Release board lock</action>

    <!-- Also update sprint-status.yaml if it exists -->
    <check if="{{sprint_status}} file exists">
      <action>Update story status to "review" in sprint-status.yaml</action>
    </check>

    <output>üöÄ **PR Created ‚Äî {{story_key}}**

      **PR:** {{pr_url}}
      **Branch:** {{branch_name}}

      **Summary:**
      {{implementation_summary}}

      **Next steps:**
      - Review and approve the PR
      - After merge, run this workflow again ‚Äî it will clean up the worktree (step 10)
      - Or start a new story in a new session
    </output>
  </step>

  <!-- =================================================================== -->
  <!-- STEP 10: POST-MERGE CLEANUP                                          -->
  <!-- =================================================================== -->
  <step n="10" goal="Clean up worktree and branch after PR merge">
    <critical>This step runs when the workflow detects a story in "review" status with a merged PR</critical>

    <!-- Verify PR is merged -->
    <action>Check PR status via: gh pr view {{pr_url}} --json state</action>

    <check if="PR is merged">
      <!-- Return to project root before cleanup -->
      <action>Change working directory back to {{project_root}}</action>

      <!-- Docker cleanup -->
      <check if="{docker_isolation} is true">
        <action>Stop and remove containers:
          docker compose -p alquileres-wt-{{story_key}} down -v</action>
        <action>Remove generated env file if it exists:
          rm -f {{worktree_path}}/{docker_env_file}</action>
        <output>üê≥ Docker containers stopped and removed for {{story_key}}</output>
      </check>

      <!-- Update main -->
      <action>git checkout main</action>
      <action>git pull origin main</action>

      <!-- Remove worktree and branch -->
      <action>git worktree remove {{worktree_path}}</action>
      <action>git branch -d {{branch_name}}</action>

      <!-- Update board -->
      <action>Acquire board lock</action>
      <action>Update story: status="done", completed_at=now</action>
      <action>Remove session from sessions registry</action>
      <action>Release board lock</action>

      <!-- Update sprint-status.yaml if exists -->
      <check if="{{sprint_status}} file exists">
        <action>Update story status to "done" in sprint-status.yaml</action>
      </check>

      <output>üèÅ **Story Complete ‚Äî {{story_key}}**
        Worktree removed, branch deleted, board updated.
        Ready for the next story!
      </output>
    </check>

    <check if="PR is NOT merged">
      <output>‚è≥ PR {{pr_url}} is not merged yet. Cleanup will happen after merge.
        Run this workflow again after the PR is merged.
      </output>
    </check>
  </step>

</workflow>
